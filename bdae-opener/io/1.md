# Input / Output Library

Developer: Irrlicht + Gameloft </br>
Complete: Yes </br>
Independent: Yes </br>
Files: 18

**Resource files** store game assets like textures, sounds, models, and scripts used during gameplay. This library provides an interface for reading these files from various sources (disk, memory, custom Pack, ZIP archives) with efficient memory management and reference counting.

Gameloft has their own **custom packed resource format** (referred to as *Pack* files), which is a variation of a ZIP archive. It compresses file metadata into a compact structure *SPackResFileEntry* to reduce memory overhead when managing many files.

`ResFileStream` – high-level wrapper that uses an *IReadResFile* object to provide stream-like reading operations. It works with any file source (disk or memory) as long as the object implements *IReadResFile*, and also utilizes *ResReferenceCounted* for automatic memory management.

`IReadResFile` (+) – interface declaration for reading resource files.

`CPackResReader` – implementation of *IReadResFile* for reading data from a Pack file.

`CZipResReader` – implementation of *IReadResFile* for reading data from a ZIP archive and loading it in the memory for subsequent access. If decompression is required, it uses the *zlib* library.

`CReadResFile` (+) – implementation of *IReadResFile* for reading data from disk.

`CMemoryReadResFile` (+) – implementation of *IReadResFile* for reading data from memory.

`ResReferenceCounted` (+) – utility for tracking how many parts of the program are using a resource (when the count drops to zero, meaning nothing is using it, the resource is safely deleted to free memory).

___
</br>

`PackPatchReader` (+) – extension of *CPackResReader* to support dynamic updates of Pack files by applying patches without replacing the main file.

`ZipPatchReader` (+) (not used) – extension of *CZipResReader* to support dynamic updates of ZIP archives.

`CLimitReadResFile` (+) (not used) – wrapper that uses an already opened *IReadResFile* object and applies constraints, such as a starting read position or a limited area size, to optimize performance in certain scenarios.
